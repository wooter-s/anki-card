单选(2分)线性表是具有n个{{c1::数据元素}}的有限序列。,<div>数据元素</div><div>表元素</div><div>字符</div><div>数据项</div>
单选(2分)线性表是{{c1::一个有限序列，可以为空}}_。,<div>一个有限序列，可以为空</div><div>一个有限序列不可以为空</div><div>一个无限序列，可以为空</div><div>一个无限序列，不可以为空</div>
单选(2分)关于线性表的正确说法是{{c1::除第一个元素和最后一个元素外，其余元素有且仅有一个前驱和一个后继元素}}_。,<div>除第一个元素和最后一个元素外，其余元素有且仅有一个前驱和一个后继元素</div><div>表中元素的排序顺序必须是由小到大或由大到小</div><div>每个元素都有一个前驱和一个后继元素</div><div>线性表中至少有一个元素</div>
单选(2分)线性表采用链表存储时，其存放各个元素的单元地址是{{c1::连续与否均可以}}_。,<div>连续与否均可以</div><div>部分地址必须是连续的</div><div>一定是不连续的</div><div>必须是连续的</div>
单选(2分)链表不具备的特点是{{c1::可随机访问任一节点}}_。,<div>可随机访问任一节点</div><div>插入删除不需要移动元素</div><div>不必事先估计存储空间</div><div>所需空间与其长度成正比</div>
单选(2分)线性表的静态链表存储结构与顺序存储结构相比，优点是{{c1::便于插入和删除}}_。,<div>便于插入和删除</div><div>所有的操作算法实现简单</div><div>便于随机存取</div><div>便于利用零散的存储器空间</div>
单选(2分)线性表的顺序存储结构和链式存储结构相比，优点是{{c1::便于随机存取 }}_。,<div>便于随机存取 </div><div>节省存储空间</div><div>便于插入和删除</div><div>所有的操作算法实现简单</div>
单选(2分)设线性表有n个元素，以下操作中，{{c1::输入第i（1<=i<=n）个元素值}}_在顺序表上实现比在链表上实现效率高。,<div>输入第i（1<=i<=n）个元素值</div><div>顺序输出这n个元素的值</div><div>输出与给定值x相等的元素在线性表中的符号</div><div>交换第1个元素第2个元素的值</div>
单选(2分)对于一个线性表，既要求能够较快地进行插入和删除操作，又要求存储结构能够反映数据元素之间的逻辑关系，则应采用 {{c1::链式}}_存储结构。,<div>链式</div><div>散列</div><div>索引</div><div>顺序</div>
单选(2分)设线性表中有n个元素，以下操作，{{c1::删除指定位置元素的后一个元素}}_在单链表上实现要比在顺序表上实现效率高。,<div>删除指定位置元素的后一个元素</div><div>交换第i个元素和第n-i+1个元素的值</div><div>在第n个元素的后面插入一个新元素</div><div>顺序输出前k个元素</div>
单选(2分)以下属于顺序表的优点是 {{c1::存储密度大}}_。,<div>存储密度大</div><div>插入元素方便</div><div>以上都不对</div><div>删除元素方便</div>
单选(2分)要求线性表采用静态空间分配方式，且插入和删除操作时不需要移动元素，采用的存储结构是 {{c1::静态链表}}_。,<div>静态链表</div><div>单链表</div><div>顺序表</div><div>双链表</div>
单选(2分)如果最常用的操作时取第i个元素及前驱元素，则采用 {{c1::顺序表}}_存储方式最节省时间。,<div>顺序表</div><div>双链表</div><div>单链表</div><div>循环单链表</div>
单选(2分)与单链表相比，双链表的优点之一是 {{c1::访问前后相邻节点更方便}}_。,<div>访问前后相邻节点更方便</div><div>可以进行随机访问</div><div>可以省略表头指针或表尾指针</div><div>插入、删除操作更简单</div>
单选(2分)在长度为n的顺序表中插入一个元素的时间复杂度为{{c1::O(n) }}_。,<div>O(n) </div><div> O()</div><div>O(1)</div><div>O(log2n)   </div>
单选(2分)在长度为n的顺序表中删除一个元素的时间复杂度为{{c1::O(n)}}_。,<div>O(n)</div><div> O(1)       </div><div>O(log2n)</div><div> O()</div>
单选(2分)在两个各有n个元素的递增有序顺序表归并成一个有序顺序表，其最少的比较次数为{{c1::n}}_。,<div>n</div><div>2n-1</div><div>n-1</div><div>2n</div>
"单选(2分)将两个长度为n、m的递增有序表归并成一个有序顺序表，其最少的比较次数是{{c1::MIN(m, n)}}_。（MIN表示取最小值）","<div>MIN(m, n)</div><div>m</div><div>不确定</div><div>n</div>"
单选(2分)在带头节点的单链表L为空的判定条件是{{c1::L->NEXT==NULL}}_。,<div>L->NEXT==NULL</div><div> L->NEXT==L</div><div> L!=NULL</div><div> L==NULL</div>
单选(2分)对于一个具有n个元素的线性表，建立其单链表的时间复杂度为 {{c1:: O(n)}}_。,<div> O(n)</div><div> O(log2n)</div><div> O()</div><div>O(1)</div>
单选(2分)在单链表中查找指定值的节点的时间复杂度是 {{c1::O(n)}}_。,<div>O(n)</div><div>O() </div><div>O(1)</div><div>O(log2n)</div>
单选(2分)以下关于单链表的叙述中，不正确的是{{c1::可以通过头节点直接计算第i个节点的存储地址}}_。,<div>可以通过头节点直接计算第i个节点的存储地址</div><div>逻辑上相邻的元素物理上不必相邻</div><div>插入、删除运算操作简单，不必移动节点</div><div>节点除自身信息外还包括指针域，因此存储密度小于顺序存储结构</div>
单选(2分)在单链表中，增加一个头节点的目的是为了{{c1::方便运算的实现 }}_。,<div>方便运算的实现 </div><div>说明单链表是线性表的链式存储结构</div><div>标识链表中重要节点的位置</div><div>使单链表至少有一个节点</div>
单选(2分)在一个具有n个节点的有序单链表中插入一个新节点并仍然保持有序的时间复杂度是{{c1:: O(n)}}_。,<div> O(n)</div><div>O(1)</div><div>O()</div><div>O(nlog2n)</div>
单选(2分)将长度为m的单链表链接在长度为n的单链表之后的算法时间复杂度为{{c1::O(n)}}_。,<div>O(n)</div><div>O(m+n)</div><div>O(1)</div><div>O(m)</div>
单选(2分)已知一个长度为n的单链表中所有节点是递增有序的，以下叙述中正确的是{{c1::找最小值节点的算法的时间复杂度为 O(1)}}_。,<div>找最小值节点的算法的时间复杂度为 O(1)</div><div>以上都不对</div><div>插入一个节点使之有序的算法的时间复杂度为O(1)</div><div>删除最大值节点使之有序的算法的时间复杂度为 O(1)</div>
单选(2分)在一个长度为n（n>1）的带头节点的单链表上，另设有尾指针r（指向尾节点），执行{{c1::删除单链表的尾节点}}_操作与链表的长度有关。,<div>删除单链表的尾节点</div><div>在单链表最后一个元素后插入一个新节点</div><div>在单链表中第一个元素前插入一个新节点</div><div>删除单链表中的第一个元素</div>
单选(2分)在一个双链表中，在*p节点之后插入节点*q的操作是{{c1::q ->next = p -> next；p -> next -> prior =q；p-> next=q；q->prior = p；}}_。,<div>q ->next = p -> next；p -> next -> prior =q；p-> next=q；q->prior = p；</div><div>p -> next -> prior =q；q->prior = p；p-> next=q；q ->next = p -> next；</div><div>q->prior = p；p-> next=q；p -> next -> prior =q； q ->next = p -> next；</div><div>p-> next=q；q->prior = p；q ->next = p -> next；p -> next -> prior =q；</div>
单选(2分)在一个双链表中，在*p节点之前插入节点*q的操作是{{c1::p -> prior ->next=q；q-> next=p；q -> prior = p->prior；p -> prior = q；}}_。,<div>p -> prior ->next=q；q-> next=p；q -> prior = p->prior；p -> prior = q；</div><div>q-> next=p；p -> next=q；q-> prior ->next= q；q-> next=p；</div><div>q ->prior= p -> prior；p -> prior ->next=q；q-> next=p；p -> prior = q->next；</div><div>p -> prior = q；q-> next=p；p -> prior ->next=q； q ->prior= p -> prior；</div>
单选(2分)在一个双链表中，删除*p节点的操作是{{c1::p -> prior –>next= p-> next；p ->next-> prior = p -> prior；}}_。,<div>p -> prior –>next= p-> next；p ->next-> prior = p -> prior；</div><div>p-> next -> prior = p；p-> next=p-> next-> next；</div><div>p ->prior= p -> prior -> prior；p -> prior ->prior = p；</div><div>p -> next= p->prior -> prior；p-> prior = p->prior->prior；</div>
单选(2分)在一个双链表中，删除*p节点之后的一个节点，其时间复杂度为{{c1::O(1) }}_。,<div>O(1) </div><div>O()</div><div>O(nlog2n) </div><div>O(n)</div>
单选(2分)非空的循环单链表L的尾节点（由p所指向）满足{{c1::p -> next == L}}_。,<div>p -> next == L</div><div>p == NULL</div><div>p-> next == NULL</div><div> p==L</div>
单选(2分)带表头结点的双循环链表L为空表的条件是{{c1::L -> next == L  }}_。,<div>L -> next == L  </div><div>L-> next -> prior == NULL</div><div>L -> prior == NULL</div><div>L== NULL</div>
单选(2分)某线性表最常用的操作是在尾元素之后插入一个元素和删除尾元素，则采用{{c1::循环双链表}}_存储方式最节省运算时间。,<div>循环双链表</div><div>双链表</div><div>循环单链表</div><div>单链表</div>
单选(2分)如果对含有n（n>1）个元素的线性表的运算只有4种，即删除第一个元素、删除尾元素、在第一个元素前面插入新元素、在尾元素的后面插入新元素，则最好使用{{c1::只有开始数据节点指针没有尾节点指针的循环双链表}}_。,<div>只有开始数据节点指针没有尾节点指针的循环双链表</div><div>既有表头指针也有表尾指针的循环单链表</div><div>只有尾节点指针没有头节点的非循环双链表</div><div>只有尾节点指针没有头节点的循环单链表</div>
单选(2分)在某线性表最常用的操作是在尾元素之后插入一个元素和删除第一个元素。故采用{{c1::仅有尾指针的循环单链表}}_存储方式最节省时间。,<div>仅有尾指针的循环单链表</div><div>单链表</div><div>双链表</div><div>仅有头节点指针的循环单链表</div>
单选(2分)两个表长都为n、不带表头结点的单链表，结点类型都相同，头指针分别为h1与h2，且前者是循环链表，后者是非循环链表，则{{c1::对于两个链表来说，删除尾节点的操作，其时间复杂度都是O(n)}}_。,<div>对于两个链表来说，删除尾节点的操作，其时间复杂度都是O(n)</div><div>循环链表要比非循环链表占用更多的内存空间</div><div>对于两个链表来说，删除首节点的操作，其时间复杂度都是O(1)</div><div>h1和h2是不同类型的变量</div>
单选(2分)在长度为n的{{c1::只有表头指针的不带表头节点的循环单链表}}_上，删除第一个元素，其算法的时间复杂度为O(n)。,<div>只有表头指针的不带表头节点的循环单链表</div><div>只有表尾指针的带表头节点的循环单链表</div><div>只有表尾指针的不带表头节点的循环单链表</div><div>只有表头指针的带表头节点的循环单链表</div>
单选(2分)下面关于线性表的叙述错误的是{{c1::线性表采用顺序存储便于插入和删除操作的实现}}_。,<div>线性表采用顺序存储便于插入和删除操作的实现</div><div>线性表采用链式存储便于插入和删除操作的实现</div><div>线性表采用链式存储不必占用一片连续的存储空间</div><div>线性表采用顺序存储必须占用一片连续的存储空间        </div>
单选(2分)对于双链表，在两个节点之间插入一个新节点是，需要修改{{c1::4}}_个指针域。,<div>4</div><div>2</div><div>1</div><div>3</div>
单选(2分)在单链表中，要删除某一指定的节点，必须找到该节点的{{c1::前驱}}_节点。,<div>前驱</div><div>头节点</div><div>尾节点</div><div>后继</div>
单选(2分)求一个单链表长度的算法的时间复杂度为 {{c1::  O(n)}}_。,<div>  O(n)</div><div> O()</div><div>O(log2n)</div><div>O(1) </div>
判断(2分)线性表中每个元素都有一个前驱元素和一个后继元素。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)线性表中所有元素的排列顺序必须从小到大或从大到小。{{c1::正确}},<div>正确</div><div>错误</div>
判断(2分)静态链表既有顺序存储结构的优点，又有动态链表的优点，所以，利用它存取第i个元素的时间与元素个数n无关。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)静态链表与动态链表在元素的插入、删除方面类似，不需要做元素的移动。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)线性表的顺序存储结构优于链式存储结构。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)在循环单链表中，从表中任一节点出发都可以通过前后移动操作遍历整个循环链表。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)在单链表中，可以从头节点开始查找任何一个节点。{{c1::错误}},<div>错误</div><div>正确</div>
判断(2分)在双链表中，可以从任一节点开始沿着同一方向查找到任何其他节点。{{c1::错误}},<div>错误</div><div>正确</div>
